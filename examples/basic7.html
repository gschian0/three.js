<!DOCTYPE html>
<html lang="en">
	<head>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
		
        </div>
        
    </body>

	<script type="module">

import * as THREE from '../build/three.module.js';
import { OrbitControls } from './jsm/controls/OrbitControls.js';
            

            
let scene, camera, renderer,clock;
let controls;

let xboxes = 10;
let group = new THREE.Group();
let newbie=[];
let size = 0.5;
let separation = 1;
group.name = 'groupy';

init();
update();
//init
function init(){
  clock = new THREE.Clock();
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0);
  let group = new THREE.Group();
  
    let light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
    scene.add( light );
    var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
    scene.add( directionalLight );

    camera = new THREE.PerspectiveCamera( 10, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.y = 200;
    camera.position.z = 1;
    camera.position.z = 150;
    camera.position.y = 10;
    camera.lookat = (0,0,0);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );
    window.addEventListener( 'resize', resize, false);
    controls = new OrbitControls( camera, renderer.domElement );
    
    scene.add(group);
    
   


    let points = [];
    let rad = 0;
    let separation = 0.5;
    for (let i = 0; i <= 200; i++) {
        points.push(new THREE.Vector3(i-separation,i-separation,0-separation));
    
    }
    let testGeo = new THREE.BoxBufferGeometry(1,1,1,1);
    let testMat = new THREE.MeshNormalMaterial();

    for(let i = 0; i< points.length; i++){
    
                newbie[i] = new THREE.Mesh(testGeo,testMat);
                newbie[i].position.x = points[i].x;
                newbie[i].position.y = points[i].y;
                newbie[i].position.z = points[i].z;
                newbie[i].scale.x = .01*points.length/2;
                newbie[i].scale.y = .01*points.length/2;
                newbie[i].scale.z = .01*points.length/2;
                group.add(newbie[i]);
                //scene.add(newbie[i]);
    
    }
    
    var center = new THREE.Vector3();
    var bbox = new THREE.Box3().setFromObject(group).getCenter(center);
    group.translateX(-center.x);
    

} 

//updates and resize
function update(group){
    requestAnimationFrame( update );
    renderer.render( scene, camera );
    controls.update();
    let time = clock.getElapsedTime();
 
    newbie.forEach((box, ndx) => {
      const speed =  ndx * .01;
      let mult = -ndx/2 ;

      newbie[ndx].position.y = 2*Math.sin(ndx+time);
      //newbie[ndx].position.z = 4*Math.sin(ndx+time);
      
    });
  
}

function resize(){
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
    

}



		</script>

</html>
